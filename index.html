<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>3D Blocks ‚Äî Solid Cube (Emoji)</title>
<style>
  :root{
    --bg:#071024;
    --panel:rgba(6,10,18,0.7);
    --accent:#FFD166;
    --muted:rgba(255,255,255,0.75);
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family:Inter,system-ui,Arial,sans-serif;
    background:linear-gradient(180deg,var(--bg) 0%, #041221 100%);
    color:#fff;
    height:100vh;
    overflow:hidden;
  }

  /* START / MENU */
  #startScreen{
    position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
    background:linear-gradient(180deg, rgba(0,0,0,0.45), rgba(0,0,0,0.6));
    z-index:20;
  }
  .menuCard{
    width:min(720px,94vw);
    background:var(--panel);padding:20px;border-radius:14px;backdrop-filter:blur(6px);
    box-shadow:0 8px 30px rgba(0,0,0,0.6);text-align:center;
  }
  .menuRow{display:flex;gap:8px;align-items:center;justify-content:center;margin-top:12px}
  input[type=number]{width:100px;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:#fff}
  button{padding:10px 14px;border-radius:8px;border:none;cursor:pointer;background:linear-gradient(90deg,#4caf50,#2e8b57);color:#fff;font-weight:600}
  .muted{color:var(--muted);font-size:13px;margin-top:8px}

  /* TOP HUD - only on puzzle screen */
  #topHUD{
    position:fixed;left:12px;right:12px;top:12px;z-index:15;display:none;
    display:flex;align-items:center;justify-content:space-between;gap:12px;
  }
  #topHUD .left, #topHUD .right{display:flex;gap:8px;align-items:center}
  .smallBtn{padding:8px 10px;border-radius:8px;border:none;background:rgba(255,255,255,0.06);color:#fff;cursor:pointer}

  /* CENTER VIEWPORT (puzzle) */
  #viewport{
    position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
  }

  /* bottom stats panel */
  #bottomPanel{
    position:fixed;left:12px;bottom:12px;padding:10px;border-radius:10px;background:var(--panel);display:flex;gap:10px;align-items:center;z-index:12;
  }
  .stat{font-size:13px;color:var(--muted)} .val{font-weight:700;color:var(--accent);margin-left:6px}

  @media(max-width:680px){
    .menuCard{padding:14px}
    #topHUD{left:6px;right:6px;top:6px}
    #bottomPanel{left:6px;right:6px;bottom:6px}
  }
</style>
</head>
<body>
  <!-- START SCREEN -->
  <div id="startScreen">
    <div class="menuCard">
      <h1>üé≤ 3D Blocks ‚Äî Solid Cube (Emoji)</h1>
      <p class="muted">Her k√º√ß√ºk k√ºp bir hayvanƒ± temsil eder (t√ºm y√ºzleri aynƒ±). Dƒ±≈ütakileri e≈üle≈ütirince i√ßtekiler g√∂r√ºn√ºr olur.</p>
      <div style="margin-top:12px">
        <label style="color:var(--muted);font-size:13px">Seviye (n) ‚Äî 3..30:</label>
        <div class="menuRow">
          <input id="menuLevel" type="number" min="3" max="30" value="3" />
          <button id="menuStart">OYUNU BA≈ûLAT</button>
          <button id="menuHow">NASIL OYNANIR</button>
        </div>
      </div>
      <p class="muted" style="margin-top:10px">Performans: n b√ºy√ºk se√ßilirse tarayƒ±cƒ± yava≈ülayabilir. Tavsiye: <strong>3‚Äì12</strong> arasƒ± test et.</p>
    </div>
  </div>

  <!-- TOP HUD -->
  <div id="topHUD">
    <div class="left">
      <div style="font-weight:700">Seviye: <span id="hudLevel">3x3x3</span></div>
      <button class="smallBtn" id="hudHint">ƒ∞pucu</button>
      <button class="smallBtn" id="hudBack">Geri</button>
    </div>
    <div class="right">
      <div style="font-size:13px;color:var(--muted)">Puan: <span id="hudScore" style="color:var(--accent);font-weight:700">0</span></div>
    </div>
  </div>

  <!-- VIEWPORT -->
  <div id="viewport"></div>

  <!-- bottom panel -->
  <div id="bottomPanel">
    <div class="stat">Hamle: <span id="hudMoves" class="val">0</span></div>
    <div class="stat">E≈üle≈üme: <span id="hudMatches" class="val">0</span></div>
    <div class="stat">Kalan: <span id="hudRemaining" class="val">0</span></div>
  </div>

  <script type="module">
    import * as THREE from 'https://esm.run/three';

    // ---------- CONFIG ----------
    const ANIMALS = ["ü¶Å","üêØ","üêª","üêº","üê∏","üêµ","üê∂","üê±","üê∞","ü¶ä","ü¶Ñ","üêÆ","üê∑","üêî","üêß","üê≠","üêπ","üêª‚Äç‚ùÑÔ∏è","üê®","üê∫"];
    const MAX_SAFE_N = 16;
    const MAX_ALLOWED_N = 30;

    // ---------- DOM ----------
    const startScreen = document.getElementById('startScreen');
    const menuStart = document.getElementById('menuStart');
    const menuLevel = document.getElementById('menuLevel');
    const menuHow = document.getElementById('menuHow');
    const topHUD = document.getElementById('topHUD');
    const hudLevel = document.getElementById('hudLevel');
    const hudHint = document.getElementById('hudHint');
    const hudBack = document.getElementById('hudBack');
    const hudScore = document.getElementById('hudScore');
    const hudMoves = document.getElementById('hudMoves');
    const hudMatches = document.getElementById('hudMatches');
    const hudRemaining = document.getElementById('hudRemaining');
    const viewport = document.getElementById('viewport');

    // ---------- THREE setup ----------
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 10000);
    const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
    renderer.setSize(innerWidth, innerHeight);
    renderer.setClearColor(0x071024, 1);
    viewport.appendChild(renderer.domElement);

    scene.add(new THREE.DirectionalLight(0xffffff,0.95).position.set(5,10,7));
    scene.add(new THREE.AmbientLight(0xffffff,0.45));

    // ---------- GAME STATE ----------
    let N = 3;
    let grid = null;
    let surfaceMeshes = [];
    let selected = null;
    let score = 0, moves = 0, matches = 0, remainingPairs = 0;
    let cellSize = 1;

    // ---------- CAMERA CONTROL ----------
    let rotX=-25, rotY=25, distance=12;
    let isPointerDown=false, pointers=new Map(), prevX=0, prevY=0, prevDist=0, isZoom=false;

    function updateCamera(){
      const rX = THREE.MathUtils.degToRad(rotX);
      const rY = THREE.MathUtils.degToRad(rotY);
      const rad = Math.max(6,distance);
      camera.position.x = rad * Math.sin(rY) * Math.cos(rX);
      camera.position.y = rad * Math.sin(rX);
      camera.position.z = rad * Math.cos(rY) * Math.cos(rX);
      camera.lookAt(0,0,0);
    }

    function animate(){ requestAnimationFrame(animate); renderer.render(scene,camera); }
    animate();

    // ---------- MATERIALS ----------
    const materialCache = new Map();
    function createEmojiTexture(emoji){
      const size = 256;
      const canvas = document.createElement('canvas');
      canvas.width = canvas.height = size;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0,0,size,size);
      ctx.font = `${size*0.7}px serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#000';
      ctx.fillText(emoji,size/2+2,size/2+2);
      ctx.fillStyle = '#fff';
      ctx.fillText(emoji,size/2,size/2);
      const tex = new THREE.CanvasTexture(canvas);
      tex.minFilter = THREE.LinearFilter;
      return tex;
    }
    function getMaterials(emoji){
      if(materialCache.has(emoji)) return materialCache.get(emoji);
      const tex=createEmojiTexture(emoji);
      const mat=new THREE.MeshLambertMaterial({map:tex});
      mat.emissive=new THREE.Color(0x000000);
      const mats=[mat,mat,mat,mat,mat,mat];
      materialCache.set(emoji,mats);
      return mats;
    }

    // ---------- HELPERS ----------
    function inRange(x){ return x>=0 && x<N; }
    function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }
    function isExposed(x,y,z){
      const neigh=[[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]];
      for(const [dx,dy,dz] of neigh){
        const nx=x+dx, ny=y+dy, nz=z+dz;
        if(!inRange(nx)||!inRange(ny)||!inRange(nz)) return true;
        const nb=grid[nx][ny][nz];
        if(!nb||nb.matched) return true;
      }
      return false;
    }

    function createAllMeshes(){
      for(const m of surfaceMeshes){ scene.remove(m); try{m.geometry.dispose();}catch(e){}}
      surfaceMeshes.length=0;
      const half=((N-1)/2)*cellSize;
      for(let x=0;x<N;x++) for(let y=0;y<N;y++) for(let z=0;z<N;z++){
        const c=grid[x][y][z];
        const g=new THREE.BoxGeometry(cellSize,cellSize,cellSize);
        const mats=getMaterials(c.animal);
        const mesh=new THREE.Mesh(g,mats);
        mesh.position.set((x*cellSize)-half,((N-1-y)*cellSize)-half,(z*cellSize)-half);
        mesh.userData.pos={x,y,z};
        mesh.userData.emoji=c.animal;
        mesh.visible=false;
        scene.add(mesh);
        c.mesh=mesh;
      }
      for(let x=0;x<N;x++) for(let y=0;y<N;y++) for(let z=0;z<N;z++){
        if(isExposed(x,y,z)&&!grid[x][y][z].matched){
          grid[x][y][z].mesh.visible=true;
          surfaceMeshes.push(grid[x][y][z].mesh);
        }
      }
    }

    function revealNeighbors(x,y,z){
      const neigh=[[1,0,0],[-1,0,0],[0,1,0],[0,-1,0],[0,0,1],[0,0,-1]];
      for(const [dx,dy,dz] of neigh){
        const nx=x+dx, ny=y+dy, nz=z+dz;
        if(inRange(nx)&&inRange(ny)&&inRange(nz)){
          const cell=grid[nx][ny][nz];
          if(cell&&!cell.matched&&!cell.mesh.visible&&isExposed(nx,ny,nz)){
            cell.mesh.visible=true;
            surfaceMeshes.push(cell.mesh);
          }
        }
      }
    }

    function removeCell(x,y,z){
      const c=grid[x][y][z];
      if(!c||c.matched) return;
      c.matched=true;
      if(c.mesh){
        const m=c.mesh, start=performance.now(), dur=280;
        (function anim(){
          const t=(performance.now()-start)/dur;
          if(t<1){ m.scale.setScalar(1-t); requestAnimationFrame(anim);}
          else{ m.visible=false; m.scale.setScalar(1);}
        })();
        const i=surfaceMeshes.indexOf(m);
        if(i>=0) surfaceMeshes.splice(i,1);
      }
    }

    function initLevel(n){
      scene.children.slice().forEach(ch=>{if(ch.type!=='DirectionalLight'&&ch.type!=='AmbientLight') scene.remove(ch);});
      N=Math.max(2,Math.min(MAX_ALLOWED_N,Math.floor(n)));
      const total=N*N*N;
      const pairCount=Math.floor(total/2);
      const list=[];
      for(let i=0;i<pairCount;i++){ const ani=ANIMALS[i%ANIMALS.length]; list.push(ani,ani);}
      if(total%2===1) list.push(ANIMALS[Math.floor(Math.random()*ANIMALS.length)]);
      shuffle(list);

      grid=[]; let idx=0;
      for(let x=0;x<N;x++){ grid[x]=[]; for(let y=0;y<N;y++){ grid[x][y]=[]; for(let z=0;z<N;z++){ grid[x][y][z]={animal:list[idx++]||ANIMALS[0],matched:false,mesh:null}; } } }

      const minDim=Math.min(innerWidth,innerHeight)*0.85;
      cellSize=Math.max(0.8,Math.min(1.5,(minDim/(N*60))*2.2));
      score=0; moves=0; matches=0; remainingPairs=Math.floor(total/2); selected=null;
      createAllMeshes();
      distance=Math.max(6,N*cellSize*1.6);
      updateCamera();

      hudLevel.textContent=`${N}x${N}x${N}`;
      hudScore.textContent=score;
      hudMoves.textContent=moves;
      hudMatches.textContent=matches;
      hudRemaining.textContent=remainingPairs;
      topHUD.style.display='flex';
      startScreen.style.display='none';

      if(N>MAX_SAFE_N) alert(`Uyarƒ±: Seviye n=${N} b√ºy√ºk ve tarayƒ±cƒ±nƒ±z yava≈ülayabilir. Tavsiye: 3..16 arasƒ± test edin.`);
    }

    // ---------- POINTER CONTROLS ----------
    renderer.domElement.addEventListener('pointerdown',e=>{
      renderer.domElement.setPointerCapture(e.pointerId);
      pointers.set(e.pointerId,e);
      if(pointers.size===1){ isPointerDown=true; prevX=e.clientX; prevY=e.clientY; isZoom=false; }
      else if(pointers.size===2){
        const it=pointers.values(); const a=it.next().value, b=it.next().value;
        prevDist=Math.hypot(a.clientX-b.clientX,a.clientY-b.clientY);
        isZoom=true;
      }
    });

    renderer.domElement.addEventListener('pointermove',e=>{
      if(!pointers.has(e.pointerId)) return;
      pointers.set(e.pointerId,e);
      if(pointers.size===1 && !isZoom && isPointerDown){
        const dx=e.clientX-prevX; const dy=e.clientY-prevY;
        rotY+=dx*0.18; rotX+=dy*0.18;
        rotX=Math.max(-85,Math.min(85,rotX));
        prevX=e.clientX; prevY=e.clientY;
        updateCamera();
      } else if(pointers.size===2){
        const it=pointers.values(); const a=it.next().value, b=it.next().value;
        const dist=Math.hypot(a.clientX-b.clientX,a.clientY-b.clientY);
        distance+=(prevDist-dist)*0.05;
        distance=Math.max(4,Math.min(120,distance));
        prevDist=dist;
        updateCamera();
      }
    });

    renderer.domElement.addEventListener('pointerup',e=>{
      pointers.delete(e.pointerId); renderer.domElement.releasePointerCapture(e.pointerId);
      if(pointers.size===0){isPointerDown=false;}
    });

    window.addEventListener('wheel', e=>{ distance+=e.deltaY*0.02; distance=Math.max(4,Math.min(120,distance)); updateCamera(); }, {passive:true});

    // ---------- START BUTTON ----------
    menuStart.addEventListener('click',()=>{ const n=Number(menuLevel.value||3); if(n<2){alert('L√ºtfen n >= 2 girin'); return;} initLevel(n); });
    menuHow.addEventListener('click',()=>{ alert('Nasƒ±l oynanƒ±r:\n- Ama√ß: aynƒ± hayvanƒ± bulup e≈üle≈ütirmek.\n- Dƒ±≈ü y√ºzeyleri e≈üle≈ütirince i√ßtekiler g√∂r√ºn√ºr.\n- Tek parmak s√ºr√ºkleme: d√∂nd√ºrme.\n- ƒ∞ki parmak pinch: yakƒ±nla≈ütƒ±rma.'); });
  </script>
</body>
</html>
